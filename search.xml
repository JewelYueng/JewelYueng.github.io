<?xml version="1.0" encoding="utf-8"?>
<search>
  
  
    
    <entry>
      <title><![CDATA[apply,call,bind]]></title>
      <url>http://yoursite.com/2017/03/25/apply-call-bind/</url>
      <content type="html"></content>
      
        
    </entry>
    
    <entry>
      <title><![CDATA[html语义化]]></title>
      <url>http://yoursite.com/2017/03/21/html%E8%AF%AD%E4%B9%89%E5%8C%96/</url>
      <content type="html"><![CDATA[<p><excerpt in="" index="" |="" 首页摘要=""><br>讲述html的语义化的具体体现<a id="more"></a></excerpt></p>
<p><the rest="" of="" contents="" |="" 余下全文=""></the></p>
<p>#什么是html语义化？</p>
<p>根据内容的结构化（内容语义化），选择合适的标签（代码语义化）便于开发者阅读和写出更优雅的代码的同时让浏览器的爬虫和机器很好地解析。</p>
]]></content>
      
        
    </entry>
    
    <entry>
      <title><![CDATA[浏览器渲染，repaint和reflow的区别和优化]]></title>
      <url>http://yoursite.com/2017/03/21/%E6%B5%8F%E8%A7%88%E5%99%A8%E6%B8%B2%E6%9F%93%EF%BC%8Crepaint%E5%92%8Creflow%E7%9A%84%E5%8C%BA%E5%88%AB%E5%92%8C%E4%BC%98%E5%8C%96/</url>
      <content type="html"><![CDATA[<p><excerpt in="" index="" |="" 首页摘要=""><br>一个优化性能的点<a id="more"></a></excerpt></p>
<the rest="" of="" contents="" |="" 余下全文="">

<h1 id="概念"><a href="#概念" class="headerlink" title="概念"></a>概念</h1><p>我们已经了解过一次完整的http事务究竟是什么样子的了，其中最接近用户的操作大概就是浏览器解析html文件，因此下面就讲一下浏览器解析的大概工作流程：</p>
<p><img src="https://sfault-image.b0.upaiyun.com/305/513/3055132361-55169ffa877a0" alt="浏览器解析的工作流程图"></p>
<p>图片来自<a href="https://segmentfault.com/a/1190000002629708" target="_blank" rel="external">Repaint、ReFlow的基本认识和优化</a></p>
<p>从图中可以看到是四个步骤：</p>
<ol>
<li>解析HTML，构建DOM树：浏览器中的渲染引擎负责解析html文档，转换树中的html标签或js生成的标签到DOM节点上，此为<strong>内容树</strong></li>
<li>构建渲染树：解析CSS，根据CSS选择器计算出节点的样式，创建<strong>渲染书</strong></li>
<li>布局渲染树：从根节点递归调用，计算每一个元素的大小位置等，给每一个节点所应该出现在屏幕上的精确坐标。</li>
<li>绘制渲染树：遍历渲染树，每个节点将使用UI后端层来绘制。</li>
</ol>
<p>其中，Reapint和Reflow出现在了第三第四步，可以大概看出来这两步都发生了什么：</p>
<ul>
<li>Reflow时，浏览器根据样式来计算，根据计算结果将元素放在它该出现的位置。</li>
<li>Repaint时，每个元素的位置的大小和位置以及其他一些属性都确定下来以后，浏览器按照这些元素的额各自特性绘制一次。</li>
</ul>
<h1 id="优化"><a href="#优化" class="headerlink" title="优化"></a>优化</h1><p>所以，这两个步骤都是整个渲染过程不可或缺的部分，我们平时口中所说的页面渲染，其实可以只发生Repaint或者Reflow也可以两个都发生，例如说以下的一些操作：</p>
<ol>
<li>对DOM节点进行增加删除修改时。</li>
<li>移动DOM节点的位置时。</li>
<li>修改DOM节点的CSS样式时</li>
<li>修改网页默认字体时</li>
</ol>
<p>而在这里不得不提一下，Reflow的成本会比Repaint的高很多，因为一个节点reflow很可能会导致父节点或者同级节点的reflow，因为reflow时计算元素应该出现的位置并且把他们放在应该出现的位置。所以大量的reflow操作是需要尽量避免的，尽量将reflow对性能的影响减到最低。</p>
<ol>
<li>js修改DOM节点样式时，不要一个属性一个属性的修改。优化方法：先定义好css的class，然后修改className</li>
</ol>
<figure class="highlight"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div></pre></td><td class="code"><pre><div class="line">//不推荐以下写法</div><div class="line">	el.style.left = 100 + 'px'</div><div class="line">	el.style.top = 200 + 'px'</div><div class="line">//推荐下面的写法</div><div class="line">&lt;style&gt;</div><div class="line">	.new_class&#123;</div><div class="line">		left: 100px;</div><div class="line">		top: 200px;</div><div class="line">	&#125;</div><div class="line">&lt;/style&gt;</div><div class="line">&lt;script&gt;</div><div class="line">	el.className += 'new_class'</div><div class="line">&lt;/script&gt;</div></pre></td></tr></table></figure>
<ol>
<li>不要把DOM节点的属性读写放在循环里，不然会大量读写该节点的属性</li>
<li>必须修改时，修改层级较低的DOM节点。</li>
<li>避免使用table布局，不然一个很小的改动会造成整个table的布局</li>
<li>把对象隐藏时，尽量使用<code>visibility: hidden;</code>代替<code>display: none;</code>因为前者只触发了repaint后者触发了reflow和repaint</li>
<li><p>把DOM节点离线后修改：</p>
<ul>
<li>使用documentFragment对象在内存里操作DOM</li>
<li>clone一个DOM节点到内存里，然后对他进行修改，改完以后跟在线的那个DOM节点交换。</li>
<li>可以先 visibility: hiidden掉一个DOM节点，然后改完以后再显示出来。</li>
</ul>
</li>
</ol>
</the>]]></content>
      
        
        <tags>
            
            <tag> 浏览器 </tag>
            
        </tags>
        
    </entry>
    
    <entry>
      <title><![CDATA[http事务]]></title>
      <url>http://yoursite.com/2017/03/21/http%E4%BA%8B%E5%8A%A1/</url>
      <content type="html"><![CDATA[<p><excerpt in="" index="" |="" 首页摘要=""><br>DNS解析域名开始，html页面是怎么出现在我们眼前的<a id="more"></a></excerpt></p>
<the rest="" of="" contents="" |="" 余下全文="">

<p>其实这篇笔记也可以勉强算做mark一下一次完整的http事务。</p>
<h1 id="大致流程："><a href="#大致流程：" class="headerlink" title="大致流程："></a>大致流程：</h1><p>域名解析 =&gt; 发起TCP三次握手 =&gt; 建立TCP连接后发起http请求 =&gt; 浏览器解析html代码,并请求html中的资源（如js、css、图片） =&gt; 浏览器对页面进行渲染呈现给用户</p>
<p>一下具体解释一下上面的各个步骤，以输入<a href="http://www.baidu.com为例" target="_blank" rel="external">http://www.baidu.com为例</a></p>
<h2 id="域名解析"><a href="#域名解析" class="headerlink" title="域名解析"></a>域名解析</h2><ol>
<li>浏览器会首先搜索浏览器自身的DNS缓存，注意这里的缓存时间比较短，大概只有一秒，而且缓存数量少，只能容纳1000条。如果浏览器自身的DNS缓存中存在“www.baidu.com”对应的条目，并且没有过期，则域名解析到此结束。如果没有找到或者找到但是已经过期，域名解析将进入下一步。</li>
<li>浏览器会搜索操作系统自身的DNS缓存，如果找到并且缓存还没有过期，则域名解析到此结束，如果没有找到或者找到但是已经过期，域名解析将进入下一步。</li>
<li>如果是在Windows系统的DNS缓存中也没有找到，那么就会尝试读取hosts文件，看看里面有没有该域名对应的ip地址，如果有则解析成功（因此Windows系统翻墙可以通过修改hosts文件做到，可是可以浏览的国外网站数量就被有限的ip地址限制了。）如果没有找到相应的ip地址，则域名解析将进入下一步。</li>
<li>浏览器发起一个DNS的系统调用，就会向本地配置的首选DNS服务器发起域名解析请求（一般是电信运营商提供），通过UDP协议向DNS的53端发起请求，这个请求是递归的请求，也就是运营商的DNS服务器必须得提供给我们该域名的ip地址。运营商的DNS服务器先看自己的缓存有没有没有过期的缓存条目，如果找到，则解析成功，如果没有找到，运营的DNS服务器会代替我们的浏览器发起迭代DNS解析请求，首先会找根域的DNS的ip地址，然后向根域发起请求询问www.baidu.com的IP，然后根域会给你com域的IP地址，接着运营商DNS服务器向com域发起请求询问www.baidu.com的IP地址，然后com域就会返回baidu.com 的ip地址，接着运营商DNS服务器就会向baidu.com发起请求询问www.baidu.com的ip地址，这个时候终于找到了www.baidu.com的ip地址，把ip地址返回给运营商DNS服务器后，运营商DNS服务器就会把结果返回给浏览器，最后浏览器拿到了相应的ip地址。</li>
</ol>
<h2 id="TCP三次握手"><a href="#TCP三次握手" class="headerlink" title="TCP三次握手"></a>TCP三次握手</h2><ol>
<li>客户端首先发送一个连接请求，ACK=0 表示确认号无效，SYN = 1 表示这是一个连接请求或连接接受报文，同时表示这个数据报不能携带数据，seq = x 表示Client自己的初始序号（seq = 0 就代表这是第0号包），这时候Client进入syn_sent状态，表示客户端等待服务器的回复</li>
<li>服务器监听到连接请求后，如同意建立连接，则向客户端发送确认。TCP报文首部中的SYN 和 ACK都置1 ，ack = x + 1表示期望收到对方下一个报文段的第一个数据字节序号是x+1，同时表明x为止的所有数据都已正确收到（ack=1其实是ack=0+1,也就是期望客户端的第1个包），seq = y 表示Server 自己的初始序号（seq=0就代表这是服务器这边发出的第0号包）。这时服务器进入syn_rcvd，表示服务器已经收到Client的连接请求，等待客户端的确认。</li>
<li>客户端收到确认后还需再次发送确认，同时携带要发送给Server的数据。ACK 置1 表示确认号ack= y + 1 有效（代表期望收到服务器的第1个包），Client自己的序号seq= x + 1（表示这就是我的第1个包，相对于第0个包来说的），一旦收到客户端的确认之后，这个TCP连接就进入Established状态，就可以发起http请求了。</li>
</ol>
<p>整个过程就像是我们的日常对话<br>“你好，你现在有空跟我聊聊吗”<br>“你好，我现在有空，可以跟你聊”<br>“好的，那我跟你说···”</p>
<p><strong>TCP协议选择三次握手的原因</strong></p>
<ol>
<li>两个计算机通信是靠协议来实现的，如果两个计算机使用的协议不一样，是不能进行通信的，这三次握手在一定意义上也是在确定通信双方是否都遵循TCP／IP协议。</li>
<li><p>最主要是为了防止已过期的连接再次穿到被连接的主机上。 考虑以下情景：</p>
<p> A：“你好，你现在有空跟我聊聊吗”</p>
<p> 此时A的问题没有正常传达给B，等了好久B还是没有回应，A决定重新问一句。</p>
<p> A：“你好，你现在有空跟我聊吗”<br> B：“可以啊有空。”<br> A：“balabalabala”<br> …</p>
<p> AB传完东西后，断开连接了，而现在，A的第一句话突然又传到了B那里，然后非常有空的B又回了一句“可以啊有空”，B以为又再次跟A连接上了，却再也等不到A的数据过来了，就会导致B空等，浪费资源。</p>
</li>
<li><p>为什么不选择两次握手？可以考虑以下的一个场景</p>
<p> A：“你好，你现在有空可以跟我聊聊嘛”<br> B：“可以啊，我现在有空”</p>
<p> 假设此时，B的回复因为奇怪的原因没有正常传达给A，即丢包了，接下来AB的反应就会可能形成死锁：</p>
<p> B觉得连接已经成功建立了，可以开始发送数据。</p>
<p> A没有收到B的回复，以为连接没有成功建立，不知道A准备好了没有，将忽略B发来的任何数据，只等待B的确定方便聊天的回复。</p>
<p> 而当B发出的请求超时后，B会重新发送同样的分组。<br> 接着就会形成死锁。</p>
</li>
</ol>
<h2 id="浏览器发起http请求"><a href="#浏览器发起http请求" class="headerlink" title="浏览器发起http请求"></a>浏览器发起http请求</h2><p>经过TCP三次握手后，浏览器发起http请求。</p>
<h2 id="服务器端响应http请求"><a href="#服务器端响应http请求" class="headerlink" title="服务器端响应http请求"></a>服务器端响应http请求</h2><p>服务器受到http请求后，就开始处理请求，处理之后就返回给浏览器html文件。</p>
<h2 id="浏览器解析html代码，并请求html代码中的资源"><a href="#浏览器解析html代码，并请求html代码中的资源" class="headerlink" title="浏览器解析html代码，并请求html代码中的资源"></a>浏览器解析html代码，并请求html代码中的资源</h2><p>浏览器拿到html文件后，就开始解析其中的html代码，遇到js／css／image等静态资源时，就向服务器端请求下载（会使用多线程下载，每个浏览器的线程数不一样），这个时候就用上了keep-alive特性了，建立一次httpi 连接，可以请求多个资源，西崽子愉安的顺序就是按照代码里的顺序，但是由于每个资源大小不一样，所以在浏览器上显示的顺序并不一定是代码里面的顺序。</p>
<p><a href="http://kb.cnblogs.com/page/129756/" target="_blank" rel="external">详细的浏览器工作原理请点击这里</a></p>
<h2 id="浏览器对页面进行渲染呈现给用户"><a href="#浏览器对页面进行渲染呈现给用户" class="headerlink" title="浏览器对页面进行渲染呈现给用户"></a>浏览器对页面进行渲染呈现给用户</h2><p>最后浏览器利用自己的内部工作机制，把请求到的静态资源和html代码进行渲染，渲染之后呈现给用户，至此完成了一次完整的http事务</p>
<p>渲染的具体过程可见：<a href="https://jewelyueng.github.io/2017/03/21/浏览器渲染，repaint和reflow的区别和优化/" target="_blank" rel="external">浏览器渲染，repaint和reflow的区别和优化</a></p>
<p>参考文章：<a href="http://www.cnblogs.com/rwind/p/5479786.html" target="_blank" rel="external">一次完整的http事务</a></p>
</the>]]></content>
      
        
        <tags>
            
            <tag> 浏览器 </tag>
            
        </tags>
        
    </entry>
    
    <entry>
      <title><![CDATA[js正则表达式]]></title>
      <url>http://yoursite.com/2017/03/21/js%E6%AD%A3%E5%88%99%E8%A1%A8%E8%BE%BE%E5%BC%8F/</url>
      <content type="html"><![CDATA[<p><excerpt in="" index="" |="" 首页摘要=""><br>深入浅出js正则表达式<a id="more"></a></excerpt></p>
<the rest="" of="" contents="" |="" 余下全文=""></the>]]></content>
      
        
        <tags>
            
            <tag> js基础 </tag>
            
        </tags>
        
    </entry>
    
    <entry>
      <title><![CDATA[js事件模型]]></title>
      <url>http://yoursite.com/2017/03/20/js%E4%BA%8B%E4%BB%B6%E6%B5%81/</url>
      <content type="html"><![CDATA[<p><excerpt in="" index="" |="" 首页摘要=""><br>简单讲述js的事件模型<a id="more"></a></excerpt></p>
<p><the rest="" of="" contents="" |="" 余下全文=""></the></p>
<h1 id="EventTarget接口"><a href="#EventTarget接口" class="headerlink" title="EventTarget接口"></a>EventTarget接口</h1><ul>
<li><p>addEventListener：绑定事件的监听函数</p>
<p>  这个函数用在当前节点或者对象上，定义一个特定事件的监听函数。</p>
  <figure class="highlight javascript"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div></pre></td><td class="code"><pre><div class="line"><span class="comment">/*调用格式：targetObject.addEventListener(type, listener[, useCapture])</span></div><div class="line">*type:事件名称，大小写敏感，例如说"click"（鼠标点击事件）</div><div class="line">*listener：监听函数。事件发生时会调用该监听函数。</div><div class="line">*useCapture：布尔值，表示函数是否在捕获阶段触发，默认为false，即监听函数只会在冒泡阶段被触发。有部分老浏览器规定该参数必选，较新版本的浏览器允许参数可选，所以为了保持兼容，建议总是写上这个参数</div><div class="line">*／</div><div class="line">//实例</div><div class="line">var button = document.getElementById('button');</div><div class="line">button.addEventListener('click',()=&gt;&#123;</div><div class="line">console.log('你点击了按钮button')</div><div class="line">&#125;,false)</div></pre></td></tr></table></figure>
</li>
</ul>
<p>addEventListener可以为当前对象添加多个监听函数。</p>
<p>注意：如果为同一时间添加同一个监听函数，则该函数只会执行一次，多余的添加会被自动去除（不必使用removeEventListener手动去除）</p>
<pre><code><figure class="highlight javascript"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div></pre></td><td class="code"><pre><div class="line"><span class="function"><span class="keyword">function</span> <span class="title">call_back</span>(<span class="params"></span>)</span>&#123;</div><div class="line">	<span class="built_in">console</span>.log(<span class="string">'call_back'</span>)</div><div class="line">&#125;;</div><div class="line">button.addEventListener(<span class="string">'click'</span>, hello, <span class="literal">false</span>);</div><div class="line">button.addEventListener(<span class="string">'click'</span>, hello, <span class="literal">false</span>);</div><div class="line"><span class="comment">//此时只会输出一次“call_back”</span></div></pre></td></tr></table></figure>
</code></pre><p>如果希望向监听函数传递参数，可用匿名函数包装</p>
<pre><code><figure class="highlight javascript"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div></pre></td><td class="code"><pre><div class="line"><span class="function"><span class="keyword">function</span> <span class="title">print</span>(<span class="params">x</span>)</span>&#123;</div><div class="line">	<span class="built_in">console</span>.log(x)</div><div class="line">&#125;</div><div class="line">button.addEventListener(<span class="string">'click'</span>,() =&gt; &#123;</div><div class="line">print(<span class="string">"hello"</span>)</div><div class="line">&#125;, <span class="literal">false</span>);</div></pre></td></tr></table></figure>
</code></pre><ul>
<li><p>removeEventListener：移除事件的监听函数</p>
<p>  removeEventListener方法用来移除addEventListener方法添加的事件监听函数。</p>
  <figure class="highlight javascript"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div></pre></td><td class="code"><pre><div class="line">	button.removeEventListener(<span class="string">'click'</span>, listener, <span class="literal">false</span>)</div><div class="line">	<span class="string">``</span><span class="string">`	</span></div><div class="line">	</div><div class="line">removeEventListener方法的参数，与addEventListener方法完全一致。它的第一个参数“事件类型”，大小写敏感。</div><div class="line">	**注意**，removeEventListener方法移除的监听函数，必须与对应的addEventListener方法的参数**完全一致**，而且必须在**同一个**元素节点，否则无效。</div><div class="line"></div><div class="line">- dispatchEvent：触发事件</div><div class="line"></div><div class="line">dispatchEvent方法在当前节点上触发指定事件，从而触发监听函数的执行。该方法返回一个布尔值，只要有一个监听函数调用了Event.preventDefault()，则返回值为false，否则为true。</div><div class="line">	</div><div class="line">	`<span class="string">``</span>javascript</div><div class="line">		para.addEventListener(<span class="string">'click'</span>, hello, <span class="literal">false</span>)</div><div class="line">		<span class="keyword">var</span> event = <span class="keyword">new</span> Event(<span class="string">'click'</span>)</div><div class="line">		para.dispatchEvent(event)</div><div class="line">		<span class="comment">//可以获取到para.dispatchEvent(event)的返回值。</span></div><div class="line">		<span class="comment">//true 被点击，false 没有被点击</span></div></pre></td></tr></table></figure>
</li>
</ul>
<h1 id="onClick和addEventListener的比较"><a href="#onClick和addEventListener的比较" class="headerlink" title="onClick和addEventListener的比较"></a>onClick和addEventListener的比较</h1><ul>
<li><h2 id="共同点"><a href="#共同点" class="headerlink" title="共同点"></a>共同点</h2><p>  都可以定义某些事件的监听代码</p>
</li>
<li><h2 id="不同点"><a href="#不同点" class="headerlink" title="不同点"></a>不同点</h2></li>
</ul>
<h3 id="绑定方法："><a href="#绑定方法：" class="headerlink" title="绑定方法："></a>绑定方法：</h3><pre><code><figure class="highlight"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div></pre></td><td class="code"><pre><div class="line">//onclick的绑定方法</div><div class="line">//在html标签中</div><div class="line">&lt;div onclick="doSomeThing()"&gt;点击这个div就可以调用函数&lt;/div&gt;</div><div class="line">//在js中</div><div class="line">//1、通过设置element节点的setAttribute方法</div><div class="line">el.setAttribute('onclick', 'doSomeThing()')</div><div class="line">//2、用.onclick指定监听方法	</div><div class="line">div.onclick = () =&gt; &#123;</div><div class="line">...</div><div class="line">&#125;</div><div class="line"></div><div class="line">//addEventListener的绑定方法</div><div class="line">//通过Element节点、document节点、window对象的addEventListener方法，也可以定义事件的监听函数。</div><div class="line">div.addEventListener('clcik',() =&gt; &#123;</div><div class="line">...</div><div class="line">&#125;,false)</div></pre></td></tr></table></figure>
</code></pre><p>在上面的三种方法中，在html中绑定监听方法在一定程度上违反了html和js代码分离的原则，而在js中通过设置onclick设置监听有一个缺点，就是同一个事件只能定义一个监听函数，重复定义的话，后一次定义会覆盖前一个，但是所有浏览器都支持着几个方法。</p>
<h3 id="触发阶段"><a href="#触发阶段" class="headerlink" title="触发阶段"></a>触发阶段</h3><pre><code>onclick的触发阶段只能在冒泡阶段出发，而addEventListener可以制定在哪个阶段（捕获阶段还是冒泡阶段）触发。
</code></pre><ul>
<li><h2 id="推荐用法"><a href="#推荐用法" class="headerlink" title="推荐用法"></a>推荐用法</h2><p>  <strong>addEventListener</strong>:</p>
<ul>
<li>可以针对同一个事件，监听多个监听函数。</li>
<li>能够指定在哪个阶段触发</li>
<li>除了DOM节点外，还可以部署在window，XMLHttpRequest灯对象上面。</li>
</ul>
</li>
</ul>
<h1 id="事件传播"><a href="#事件传播" class="headerlink" title="事件传播"></a>事件传播</h1><p>事件的传播模型分成三个阶段</p>
<ul>
<li>第一阶段：从window对象传导到目标节点，称为<strong>捕获阶段</strong>(capture phase)</li>
<li>第二阶段：在目标节点上触发。称为<strong>目标阶段</strong>（target phase）</li>
<li>第三阶段：从目标节点传导回window对象，称为<strong>冒泡阶段</strong>（bubbling phase）</li>
</ul>
<h1 id="事件代理／事件委托"><a href="#事件代理／事件委托" class="headerlink" title="事件代理／事件委托"></a>事件代理／事件委托</h1><p>由于时间会在冒泡阶段向上传播到父节点，因此可以吧子节点的监听函数定义在父节点上，由父节点的监听函数统一处理多个子元素的事件，这种方法叫做<strong>事件的代理（delegation）</strong></p>
<p>这样做的好处是：只要定义一个监听函数，就能处理多个子节点的事件，而且<strong>以后再添加子节点，监听函数依然有效</strong></p>
<p>如果希望事件到某个节点为止，不再传播，可以使用事件对象的stopPropagation方法。</p>
<p>但是stopPropagation方法只会阻止当前监听函数的传播，不会阻止同节点上的其他监听函数的传播，如果想不再触发那些监听函数，可以使用stopImmediatePropagation方法</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div></pre></td><td class="code"><pre><div class="line">p.addEventListener(<span class="string">'click'</span>,(event) =&gt; &#123;</div><div class="line">	event.stopImmediatePropagation()</div><div class="line">&#125;)</div><div class="line">p.addEventListener(<span class="string">'click'</span>, () =&gt; &#123;</div><div class="line">	...</div><div class="line">	<span class="comment">//不会被触发</span></div><div class="line">&#125;)</div></pre></td></tr></table></figure>
<p><a href="http://javascript.ruanyifeng.com/dom/event.html#toc10" target="_blank" rel="external">参考链接:事件模型</a></p>
]]></content>
      
        
        <tags>
            
            <tag> js基础 </tag>
            
        </tags>
        
    </entry>
    
    <entry>
      <title><![CDATA[让一个元素看不见的方法]]></title>
      <url>http://yoursite.com/2017/03/18/%E8%AE%A9%E4%B8%80%E4%B8%AA%E5%85%83%E7%B4%A0%E7%9C%8B%E4%B8%8D%E8%A7%81%E7%9A%84%E6%96%B9%E6%B3%95/</url>
      <content type="html"><![CDATA[<p><excerpt in="" index="" |="" 首页摘要=""><br>讲述如何使一个元素从看得见到看不见的所有办法<a id="more"></a></excerpt></p>
<the rest="" of="" contents="" |="" 余下全文="">

<p>接下来介绍几个可以隐藏元素的方法：</p>
<ul>
<li>{display:none;}</li>
<li>{visibility: hidden;}</li>
<li>{position: absolute; top: -999em;}</li>
<li>{position: relative; top: -999em;}</li>
<li>{position: absolute; visibility: hidden;}</li>
<li>{height: 0; overflow: hidden;}</li>
<li>{opacity: 0; filter:Alpha(opacity=0);}</li>
<li>{ position: absolute; opacity: 0; filter:Alpha(opacity=0); }</li>
</ul>
</the>]]></content>
      
        
        <tags>
            
            <tag> css应用 </tag>
            
        </tags>
        
    </entry>
    
    <entry>
      <title><![CDATA[js模块化]]></title>
      <url>http://yoursite.com/2017/03/18/js%E6%A8%A1%E5%9D%97%E5%8C%96/</url>
      <content type="html"><![CDATA[<p><excerpt in="" index="" |="" 首页摘要=""><br>js模块化<a id="more"></a></excerpt></p>
<the rest="" of="" contents="" |="" 余下全文=""></the>]]></content>
      
        
        <tags>
            
            <tag> js基础 </tag>
            
        </tags>
        
    </entry>
    
    <entry>
      <title><![CDATA[水平竖直居中的方法]]></title>
      <url>http://yoursite.com/2017/03/17/%E6%B0%B4%E5%B9%B3%E7%AB%96%E7%9B%B4%E5%B1%85%E4%B8%AD%E7%9A%84%E6%96%B9%E6%B3%95/</url>
      <content type="html"><![CDATA[<p><excerpt in="" index="" |="" 首页摘要=""><br>教你如何用css做到使一个元素在水平方向上和竖直方向上的居中<a id="more"></a></excerpt></p>
<the rest="" of="" contents="" |="" 余下全文="">

<p>以下是可以使元素快块居中的css：</p>
<p>1.<br>    <figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div></pre></td><td class="code"><pre><div class="line">&#123;</div><div class="line">	width: 400px;</div><div class="line">	height: 200px;</div><div class="line">	position: absolute;</div><div class="line">	left: 50%;</div><div class="line">	top: 50%;</div><div class="line">	margin: -100px 0 0 -200px;</div><div class="line">&#125;</div></pre></td></tr></table></figure></p>
<p>2.<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div></pre></td><td class="code"><pre><div class="line">&#123;</div><div class="line">	width: 400px;</div><div class="line">	height: 200px;</div><div class="line">	position: absolute;</div><div class="line">	top: 0;</div><div class="line">	left: 0;</div><div class="line">	right: 0;</div><div class="line">	bottom: 0;</div><div class="line">	margin: auto;</div><div class="line">&#125;</div></pre></td></tr></table></figure></p>
<p>3.<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div></pre></td><td class="code"><pre><div class="line">&#123;</div><div class="line">	width: 400px;</div><div class="line">	height: 200px;</div><div class="line">	position: absolute;</div><div class="line">	top: 0;</div><div class="line">	left: 0;</div><div class="line">	right: 0;</div><div class="line">	bottom: 0;</div><div class="line">	margin: auto;</div><div class="line">&#125;</div></pre></td></tr></table></figure></p>
<p>4.<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div></pre></td><td class="code"><pre><div class="line">&#123;</div><div class="line">	width: 50%;</div><div class="line">	background: red;</div><div class="line">	display: inline-block;</div><div class="line">	vertical-align: middle;</div><div class="line">&#125;</div></pre></td></tr></table></figure></p>
<p>5.使用table-cell来辅助实现，实现的时候需要用三层元素从而使最里层元素居中。需要的可以直接google一下。。。<br>6.目前使用最开心的flex-box布局实现居中，但是也要借助父元素来子元素的居中。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div></pre></td><td class="code"><pre><div class="line">.father&#123;</div><div class="line"> 	display: flex;</div><div class="line"> 	flex-direction: row;</div><div class="line"> 	//其实这里使用row或者column都没有问题</div><div class="line"> 	align-items: center;</div><div class="line"> 	justify-contents: center;</div><div class="line">&#125;</div><div class="line">.son&#123;</div><div class="line">	flex: 0 1 100px;</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p>对flex-box不了解的话可以回去 mdn说明文档细看。</p>
<p><a href="http://the-echoplex.net/flexyboxes/" target="_blank" rel="external">flex-box试验场</a></p>
</the>]]></content>
      
        
        <tags>
            
            <tag> css应用 </tag>
            
        </tags>
        
    </entry>
    
    <entry>
      <title><![CDATA[Snake文档]]></title>
      <url>http://yoursite.com/2017/03/17/Snake%E6%96%87%E6%A1%A3/</url>
      <content type="html"><![CDATA[<p><excerpt in="" index="" |="" 首页摘要=""><br>这是一款用vue.js实现的贪吃蛇页游。下面介绍一下实现时的思想。<a id="more"></a></excerpt></p>
<p><the rest="" of="" contents="" |="" 余下全文=""></the></p>
<h1 id="snake介绍"><a href="#snake介绍" class="headerlink" title="snake介绍"></a>snake介绍</h1><p>a Vue webPage for snake game</p>
<p>这是一款用vue.js实现的贪吃蛇页游。下面介绍一下实现时的思想。</p>
<p>PS：逻辑运算都放在script标签内</p>
<p><a href="https://github.com/JewelYueng/snake" target="_blank" rel="external">项目地址:https://github.com/JewelYueng/snake</a></p>
<h1 id="设计数据结构"><a href="#设计数据结构" class="headerlink" title="设计数据结构"></a>设计数据结构</h1><ul>
<li><strong>Step 1：</strong>根据贪吃蛇的运行情况，大致分成三个数据结构，分别是Fruit（随机出现的水果）、Snake（蛇）、Game（负责管理游戏的运行状态）</li>
<li><strong>Step 2：</strong>细化Fruit和Snake数据结构内部。</li>
</ul>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div><div class="line">31</div><div class="line">32</div><div class="line">33</div><div class="line">34</div><div class="line">35</div><div class="line">36</div><div class="line">37</div><div class="line">38</div><div class="line">39</div></pre></td><td class="code"><pre><div class="line"><span class="class"><span class="keyword">class</span> <span class="title">Fruit</span> </span>&#123;</div><div class="line">       <span class="keyword">constructor</span>(x, y)&#123;</div><div class="line">           <span class="comment">// 确定水果的坐标，也可添加别的参数，例如水果的分值，不设置就默认为1</span></div><div class="line">           <span class="keyword">this</span>.x = x;</div><div class="line">           <span class="keyword">this</span>.y = y;</div><div class="line">       &#125;</div><div class="line">   &#125;</div><div class="line">   <span class="class"><span class="keyword">class</span> <span class="title">Snake</span> </span>&#123;</div><div class="line"></div><div class="line">       <span class="keyword">constructor</span>(sHead)&#123;</div><div class="line">           <span class="comment">// 蛇身的坐标数组</span></div><div class="line">           <span class="keyword">let</span> point = &#123;<span class="attr">x</span>: <span class="number">0</span>,<span class="attr">y</span>: <span class="number">0</span>&#125;;</div><div class="line">           <span class="keyword">let</span> point_array = [];</div><div class="line">           <span class="keyword">for</span>(<span class="keyword">let</span> i = <span class="number">0</span>; i &lt; <span class="number">3</span> ; i++ )&#123;</div><div class="line">               point = &#123;<span class="attr">x</span> : sHead.x , <span class="attr">y</span> : sHead.y + i&#125;;</div><div class="line">               point_array[i] = point;</div><div class="line">           &#125;</div><div class="line">           <span class="keyword">this</span>.point_array = point_array;</div><div class="line">       &#125;</div><div class="line"></div><div class="line">       length()&#123;</div><div class="line">       	<span class="comment">//获得蛇的长度</span></div><div class="line">           <span class="keyword">return</span> <span class="keyword">this</span>.point_array.length;</div><div class="line">       &#125;</div><div class="line">	<span class="comment">//蛇吃了水果以后长大的实现函数</span></div><div class="line">       growUp(direction)&#123;</div><div class="line">           <span class="keyword">let</span> newHead = &#123;<span class="attr">x</span> : <span class="keyword">this</span>.point_array[<span class="number">0</span>].x + direction.x , <span class="attr">y</span> : <span class="keyword">this</span>.point_array[<span class="number">0</span>].y + direction.y&#125;;</div><div class="line">           <span class="keyword">this</span>.point_array = [newHead].concat(<span class="keyword">this</span>.point_array);</div><div class="line">       &#125;</div><div class="line">	<span class="comment">//蛇往前走时，把蛇尾的小方格删掉，在蛇头多添一个小方格</span></div><div class="line">       goAhead(direction)&#123;</div><div class="line">           <span class="keyword">let</span> newHead = &#123;<span class="attr">x</span> : <span class="keyword">this</span>.point_array[<span class="number">0</span>].x + direction.x , <span class="attr">y</span> : <span class="keyword">this</span>.point_array[<span class="number">0</span>].y + direction.y&#125;;</div><div class="line">           <span class="keyword">this</span>.point_array = [newHead].concat(<span class="keyword">this</span>.point_array.slice(<span class="number">0</span>,<span class="number">-1</span>));</div><div class="line">       &#125;</div><div class="line">	<span class="comment">//获取蛇身坐标点的数组</span></div><div class="line">       getPointArray()&#123;</div><div class="line">           <span class="keyword">return</span> <span class="keyword">this</span>.point_array;</div><div class="line">       &#125;</div><div class="line">   &#125;</div></pre></td></tr></table></figure>
<ul>
<li><strong>Step 3：</strong>根据游戏运行状态，细化Game类</li>
</ul>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div><div class="line">31</div><div class="line">32</div><div class="line">33</div><div class="line">34</div><div class="line">35</div><div class="line">36</div><div class="line">37</div><div class="line">38</div><div class="line">39</div><div class="line">40</div><div class="line">41</div><div class="line">42</div><div class="line">43</div><div class="line">44</div><div class="line">45</div><div class="line">46</div><div class="line">47</div><div class="line">48</div><div class="line">49</div><div class="line">50</div><div class="line">51</div><div class="line">52</div><div class="line">53</div><div class="line">54</div><div class="line">55</div><div class="line">56</div><div class="line">57</div><div class="line">58</div><div class="line">59</div><div class="line">60</div><div class="line">61</div><div class="line">62</div><div class="line">63</div><div class="line">64</div><div class="line">65</div><div class="line">66</div><div class="line">67</div><div class="line">68</div><div class="line">69</div><div class="line">70</div><div class="line">71</div><div class="line">72</div><div class="line">73</div><div class="line">74</div><div class="line">75</div><div class="line">76</div><div class="line">77</div><div class="line">78</div><div class="line">79</div><div class="line">80</div><div class="line">81</div><div class="line">82</div><div class="line">83</div><div class="line">84</div><div class="line">85</div><div class="line">86</div><div class="line">87</div><div class="line">88</div><div class="line">89</div><div class="line">90</div><div class="line">91</div><div class="line">92</div><div class="line">93</div><div class="line">94</div><div class="line">95</div><div class="line">96</div><div class="line">97</div><div class="line">98</div><div class="line">99</div><div class="line">100</div><div class="line">101</div><div class="line">102</div><div class="line">103</div><div class="line">104</div><div class="line">105</div><div class="line">106</div><div class="line">107</div><div class="line">108</div><div class="line">109</div><div class="line">110</div><div class="line">111</div><div class="line">112</div><div class="line">113</div><div class="line">114</div><div class="line">115</div><div class="line">116</div><div class="line">117</div><div class="line">118</div><div class="line">119</div><div class="line">120</div><div class="line">121</div><div class="line">122</div><div class="line">123</div><div class="line">124</div><div class="line">125</div></pre></td><td class="code"><pre><div class="line"><span class="comment">//每一局游戏都有一条蛇，每个时间点存在的唯一的水果，以及蛇目前的方向，以及游戏盘的大小</span></div><div class="line"><span class="class"><span class="keyword">class</span> <span class="title">Game</span></span>&#123;</div><div class="line">        <span class="keyword">constructor</span>(snake,dir,fruit,width,height)&#123;</div><div class="line">            <span class="keyword">this</span>.snake = snake;</div><div class="line">            <span class="keyword">this</span>.direction = dir;</div><div class="line">            <span class="keyword">this</span>.fruit = fruit;</div><div class="line">            <span class="keyword">this</span>.width = width;</div><div class="line">            <span class="keyword">this</span>.height = height;</div><div class="line">        &#125;</div><div class="line">		<span class="comment">//nextStep()是一层很关键的抽象</span></div><div class="line">        nextStep()&#123;</div><div class="line">            <span class="keyword">const</span> n = <span class="keyword">this</span>.check();</div><div class="line">            <span class="keyword">switch</span> (n) &#123;</div><div class="line">                <span class="keyword">case</span> <span class="number">1</span>: <span class="keyword">return</span> <span class="keyword">this</span>.gameAhead();</div><div class="line">                <span class="keyword">case</span> <span class="number">2</span>: <span class="keyword">return</span> <span class="keyword">this</span>.growUp();</div><div class="line">                <span class="keyword">case</span> <span class="number">3</span>: <span class="keyword">return</span> <span class="keyword">this</span>.die();</div><div class="line">            &#125;</div><div class="line"></div><div class="line">        &#125;</div><div class="line"></div><div class="line">        setDirection(dir)&#123;</div><div class="line">            <span class="keyword">this</span>.direction = dir;</div><div class="line">        &#125;</div><div class="line"></div><div class="line">        setFruit()&#123;</div><div class="line">            <span class="keyword">let</span> fruitX = <span class="built_in">parseInt</span>(<span class="built_in">Math</span>.random() * <span class="keyword">this</span>.width);</div><div class="line">            <span class="keyword">let</span> fruitY = <span class="built_in">parseInt</span>(<span class="built_in">Math</span>.random() * <span class="keyword">this</span>.height);</div><div class="line">            <span class="keyword">this</span>.fruit.x = fruitX;</div><div class="line">            <span class="keyword">this</span>.fruit.y = fruitY;</div><div class="line">        &#125;</div><div class="line"></div><div class="line"></div><div class="line">        gameAhead()&#123;</div><div class="line">            <span class="keyword">this</span>.snake.goAhead(<span class="keyword">this</span>.direction);</div><div class="line">            <span class="keyword">return</span> &#123;<span class="attr">alive</span>: <span class="literal">true</span>, <span class="attr">map</span>: <span class="keyword">this</span>.draw(), <span class="attr">length</span>: <span class="keyword">this</span>.snake.length()&#125;;</div><div class="line">        &#125;</div><div class="line"></div><div class="line">        growUp()&#123;</div><div class="line">            <span class="keyword">this</span>.snake.growUp(<span class="keyword">this</span>.direction);</div><div class="line">            <span class="keyword">return</span> &#123;<span class="attr">alive</span>: <span class="literal">true</span>, <span class="attr">map</span>: <span class="keyword">this</span>.draw(), <span class="attr">length</span>: <span class="keyword">this</span>.snake.length()&#125;;</div><div class="line">        &#125;</div><div class="line"></div><div class="line">        die()&#123;</div><div class="line">            <span class="keyword">return</span> &#123;<span class="attr">alive</span>: <span class="literal">false</span>, <span class="attr">map</span>: <span class="keyword">this</span>.draw(), <span class="attr">length</span>: <span class="keyword">this</span>.snake.length()&#125;;</div><div class="line">        &#125;</div><div class="line"></div><div class="line">        draw()&#123;</div><div class="line"><span class="comment">//            Initialize the board</span></div><div class="line">            <span class="keyword">let</span> board = [];</div><div class="line">            <span class="keyword">let</span> isEmpty = <span class="literal">true</span>;</div><div class="line">            <span class="keyword">for</span> (<span class="keyword">let</span> i = <span class="number">0</span>;i &lt; <span class="number">30</span>;i++ )&#123;</div><div class="line">                <span class="keyword">let</span> boardLine = [];</div><div class="line">                board.push(boardLine);</div><div class="line">                <span class="keyword">for</span> (<span class="keyword">let</span> j = <span class="number">0</span>;j &lt; <span class="number">30</span>;j++)&#123;</div><div class="line">                    boardLine.push(<span class="number">0</span>);</div><div class="line">                &#125;</div><div class="line">            &#125;</div><div class="line">            <span class="keyword">for</span>(<span class="keyword">let</span> y = <span class="number">0</span>;y &lt; <span class="keyword">this</span>.width;y++)&#123;</div><div class="line">                <span class="keyword">for</span>(<span class="keyword">let</span> x = <span class="number">0</span>;x &lt; <span class="keyword">this</span>.height;x++)&#123;</div><div class="line">                    isEmpty = <span class="literal">true</span>;</div><div class="line">                    <span class="keyword">for</span>(<span class="keyword">let</span> k = <span class="number">0</span>; k &lt; <span class="keyword">this</span>.snake.length();k++)&#123;</div><div class="line">                        <span class="keyword">if</span>(y == <span class="keyword">this</span>.snake.point_array[<span class="number">0</span>].y &amp;&amp; x == <span class="keyword">this</span>.snake.point_array[<span class="number">0</span>].x)&#123;</div><div class="line">                            board[y][x] = <span class="number">1</span>;</div><div class="line">                            isEmpty = <span class="literal">false</span>;<span class="literal">true</span></div><div class="line">                            <span class="keyword">continue</span>;</div><div class="line">                        &#125;</div><div class="line">                        <span class="keyword">if</span>(y == <span class="keyword">this</span>.snake.point_array[k].y &amp;&amp; x == <span class="keyword">this</span>.snake.point_array[k].x)&#123;</div><div class="line">                            board[y][x] = <span class="number">2</span>;</div><div class="line">                            isEmpty = <span class="literal">false</span>;</div><div class="line">                        &#125;</div><div class="line">                        <span class="keyword">if</span>(y == <span class="keyword">this</span>.fruit.y &amp;&amp; x == <span class="keyword">this</span>.fruit.x)&#123;</div><div class="line">                            board[y][x] = <span class="number">3</span>;</div><div class="line">                            isEmpty = <span class="literal">false</span>;</div><div class="line">                        &#125;</div><div class="line">                    &#125;</div><div class="line">                    <span class="keyword">if</span> (isEmpty)</div><div class="line">                        board[y][x] = <span class="number">0</span>;</div><div class="line">                &#125;</div><div class="line">            &#125;</div><div class="line"></div><div class="line">            <span class="keyword">return</span> board;</div><div class="line">        &#125;</div><div class="line">        check()&#123;</div><div class="line">            <span class="keyword">if</span>(!<span class="keyword">this</span>.checkSnake()) <span class="keyword">return</span> <span class="number">3</span>;</div><div class="line">            <span class="keyword">else</span> &#123;</div><div class="line">                <span class="keyword">if</span>(<span class="keyword">this</span>.eatFruit())&#123;</div><div class="line">                    <span class="keyword">do</span> &#123;</div><div class="line">                        <span class="keyword">this</span>.setFruit();</div><div class="line">                    &#125;<span class="keyword">while</span>(<span class="keyword">this</span>.checkFruit());</div><div class="line">                    <span class="keyword">return</span> <span class="number">2</span>;</div><div class="line">                &#125;</div><div class="line"></div><div class="line">                <span class="keyword">return</span> <span class="number">1</span>;</div><div class="line">            &#125;</div><div class="line">        &#125;</div><div class="line"></div><div class="line">        checkFruit()&#123;</div><div class="line">            <span class="keyword">for</span>(<span class="keyword">let</span> j = <span class="number">0</span> ; j &lt; <span class="keyword">this</span>.snake.length() ; j++)&#123;</div><div class="line">                <span class="keyword">if</span>(<span class="keyword">this</span>.fruit.x == <span class="keyword">this</span>.snake.point_array[j].x &amp;&amp; <span class="keyword">this</span>.fruit.y == <span class="keyword">this</span>.snake.point_array[j].y)&#123;</div><div class="line">                    <span class="keyword">this</span>.setFruit();</div><div class="line">                    <span class="keyword">return</span> <span class="literal">false</span>;</div><div class="line">                &#125;</div><div class="line">            &#125;</div><div class="line">            <span class="keyword">return</span> <span class="literal">true</span>;</div><div class="line">        &#125;</div><div class="line">        checkSnake()&#123;</div><div class="line">            <span class="keyword">let</span> head = <span class="keyword">this</span>.snake.point_array[<span class="number">0</span>];</div><div class="line">            <span class="keyword">let</span> newHead = &#123;<span class="attr">x</span> : head.x + <span class="keyword">this</span>.direction.x , <span class="attr">y</span> : head.y + <span class="keyword">this</span>.direction.y&#125;;</div><div class="line">            <span class="keyword">let</span> point_array = <span class="keyword">this</span>.snake.point_array;</div><div class="line">            point_array = [newHead].concat(point_array.slice(<span class="number">0</span>,<span class="number">-1</span>));</div><div class="line"><span class="comment">//            touch the border</span></div><div class="line">            <span class="keyword">if</span>(newHead.x &gt;= <span class="keyword">this</span>.width || newHead.x &lt; <span class="number">0</span> || newHead.y &lt; <span class="number">0</span> || newHead.y &gt;= <span class="keyword">this</span>.height) <span class="keyword">return</span> <span class="literal">false</span>;</div><div class="line"><span class="comment">//            kill itself</span></div><div class="line">            <span class="keyword">for</span> (<span class="keyword">let</span> i = <span class="number">1</span>;i &lt; <span class="keyword">this</span>.snake.length();i++)&#123;</div><div class="line">                <span class="keyword">if</span>(point_array[i].x == newHead.x &amp;&amp; point_array[i].y == newHead.y)</div><div class="line">                    <span class="keyword">return</span> <span class="literal">false</span>;</div><div class="line">            &#125;</div><div class="line">            <span class="keyword">return</span> <span class="literal">true</span>;</div><div class="line">        &#125;</div><div class="line"></div><div class="line">        eatFruit()&#123;</div><div class="line">            <span class="keyword">return</span> (<span class="keyword">this</span>.snake.point_array[<span class="number">0</span>].x == <span class="keyword">this</span>.fruit.x &amp;&amp; <span class="keyword">this</span>.snake.point_array[<span class="number">0</span>].y == <span class="keyword">this</span>.fruit.y);</div><div class="line">        &#125;</div><div class="line"></div><div class="line">    &#125;</div></pre></td></tr></table></figure>
<ul>
<li><p><strong>Step 4：</strong>初始化你的游戏状态</p>
<pre><code class="javascript"><span class="function"><span class="keyword">function</span> <span class="title">GameInit</span>(<span class="params"></span>) </span>{
    <span class="keyword">let</span> width = <span class="number">30</span>;
    <span class="keyword">let</span> height = <span class="number">30</span>;
    <span class="keyword">let</span> snakeHead = {<span class="attr">x</span> : <span class="number">14</span> , <span class="attr">y</span> : <span class="number">14</span>};
    <span class="keyword">let</span> fruit = {<span class="attr">x</span>:<span class="number">15</span>,<span class="attr">y</span>:<span class="number">15</span>};
    <span class="keyword">let</span> snake = <span class="keyword">new</span> Snake(snakeHead);
    <span class="keyword">let</span> newGame = <span class="keyword">new</span> Game(snake,UP,fruit,width,height);
    <span class="keyword">return</span> newGame;
}
</code></pre>
</li>
</ul>
]]></content>
      
        
        <tags>
            
            <tag> 项目文档 </tag>
            
        </tags>
        
    </entry>
    
    <entry>
      <title><![CDATA[js类型]]></title>
      <url>http://yoursite.com/2017/03/12/js%E7%B1%BB%E5%9E%8B/</url>
      <content type="html"><![CDATA[<p><excerpt in="" index="" |="" 首页摘要=""><br>关于js基本类型的容易混淆点，双等号和三等号的区别，基本数据类型和引用数据类型的辨析<a id="more"></a></excerpt></p>
<p><the rest="" of="" contents="" |="" 余下全文=""><br>javascript里面包含了<strong>七种</strong>数据类型，其中6种称为<strong>基本数据类型</strong>(Boolean, null, undefined, Number, String, Symbol),剩下的就是Object对象。</the></p>
<p>其中：<br>Boolean: 布尔值，true和false<br>null: 一个表明 null 值的特殊关键字。 JavaScript 是大小写敏感的，<strong>因此 null 与 Null、NULL或其他变量完全不同</strong>。<br>undefined: 变量未定义时的属性。<br>Number: 表示数字。<br>String: 表示字符串。<br>Symbol: ES6新增的数据类型，它的实例是唯一的且不可改变的。  </p>
<p>接下来讨论几点比较容易迷惑的地方：  </p>
<ol>
<li><p>==与===的区别<br>==是比较值，而===是比较堆地址</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">let</span> a = <span class="string">"1"</span>;</div><div class="line"><span class="keyword">let</span> b = <span class="keyword">new</span> <span class="built_in">String</span>(<span class="string">"1"</span>);</div><div class="line"><span class="built_in">console</span>.log(a == b);</div><div class="line"><span class="comment">//true</span></div><div class="line"><span class="built_in">console</span>.log(a === b);</div><div class="line"><span class="comment">//false,因为a和b指向的堆地址不同</span></div></pre></td></tr></table></figure>
</li>
<li><p>false的等效值:  </p>
</li>
</ol>
<ul>
<li>false</li>
<li>undefined</li>
<li>null</li>
<li>0</li>
<li>NaN</li>
<li>空字符串””<br><strong>请注意：不要混淆原始布尔值的true和false 与 布尔对象的true和false</strong><pre><code class="javascript"><span class="keyword">let</span> a = <span class="keyword">new</span> <span class="built_in">Boolean</span>(<span class="literal">false</span>)  
<span class="keyword">if</span>(a){
  ...
<span class="comment">//此时将执行代码</span>
}  
<span class="keyword">if</span>(a == <span class="literal">true</span>){  
  ...
<span class="comment">//  此时不会执行代码</span>
}
</code></pre>
</li>
</ul>
<ol>
<li>有关于包装类型<br>ECMAScript还提供了三个特殊的引用类型Boolean,String,Number。我们称这三个特殊的引用类型为基本包装类型，也叫<strong>包装对象</strong>.也就是说当读取string,boolean和number这三个基本数据类型的时候，后台就会创建一个对应的基本包装类型对象，从而让我们能够调用一些方法来操作这些数据。  <pre><code class="javascript"><span class="keyword">let</span> str = <span class="string">"12213"</span>
<span class="keyword">let</span> strNum = str.substr(<span class="number">2</span>)
<span class="comment">/*
当第二行代码访问str时后台有以下操作  
1.创建String类型的一个实例  
2.在实例上调用指定方法    
3.销毁这个实例  
*／</span>
</code></pre>
</li>
</ol>
<p>正因为有第三步这个销毁的动作，所以你应该能够明白为什么基本数据类型不可以添加属性和方法，这也正是基本装包类型和引用类型主要区别：对象的生存期.使用new操作符创建的引用类型的实例，在执行流离开当前作用域之前都是一直保存在内存中.而自动创建的基本包装类型的对象，则只存在于一行代码的执行瞬间，然后立即被销毁<br><a href="http://www.html-js.com/article/4015" target="_blank" rel="external">基本数据类型和引用类型的区别详解</a><br><a href="https://developer.mozilla.org/zh-CN/docs/Web/JavaScript/Guide/Grammar_and_Types" target="_blank" rel="external">js的数据类型|mdn</a></p>
]]></content>
      
        
        <tags>
            
            <tag> jvascript基础 </tag>
            
        </tags>
        
    </entry>
    
  
  
</search>
